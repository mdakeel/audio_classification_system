import os
import sys
import joblib
import torch
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader, random_split
import torchvision.transforms as tt

from src.constants import *
from src.logger import logging
from src.exception import CustomException
from src.entity.config_entity import ModelTrainerConfig
from src.entity.artifact_entity import DataTransformationArtifacts, ModelTrainerArtifacts
from src.entity.custom_model import ResNet9
from src.utils import get_default_device, to_device, DeviceDataLoader, my_fit_method

class ModelTraining:
    """
    Trains ResNet9 on spectrogram images generated by DataTransformation.
    - Loads images from artifacts/data_transformation/spectrograms
    - Splits training data into train/validation
    - Trains model and saves weights + transform
    """

    def __init__(self, data_transformation_artifact: DataTransformationArtifacts,
                 model_trainer_config: ModelTrainerConfig):
        self.model_trainer_config = model_trainer_config
        self.data_transformation_artifact = data_transformation_artifact

    def get_data_loader(self, train_data: ImageFolder):
        """
        Splits dataset into train/val and returns DataLoaders.
        """
        try:
            val_size = int(len(train_data) * 0.2)
            train_size = len(train_data) - val_size

            logging.info("Splitting dataset into train and validation sets")
            train_ds, val_ds = random_split(train_data, [train_size, val_size])

            training_dl = DataLoader(train_ds, BATCH_SIZE, shuffle=True, num_workers=NUM_WORKERS, pin_memory=PIN_MEMORY)
            valid_dl = DataLoader(val_ds, BATCH_SIZE * 2, shuffle=False, num_workers=NUM_WORKERS, pin_memory=PIN_MEMORY)

            logging.info(f"Train batches: {len(training_dl)}, Val batches: {len(valid_dl)}")
            return training_dl, valid_dl
        except Exception as e:
            raise CustomException(e, sys)

    def get_model(self, train_data: ImageFolder):
        """
        Creates ResNet9 with correct number of classes.
        """
        try:
            logging.info("Initializing ResNet9")
            num_classes = len(train_data.classes)
            model = ResNet9(IN_CHANNELS, num_classes)
            return model
        except Exception as e:
            raise CustomException(e, sys)

    def load_to_gpu(self, training_dl, valid_dl, model):
        """
        Moves model and dataloaders to GPU if available.
        """
        try:
            logging.info("Moving model and data to device")
            device = get_default_device()
            model = to_device(model, device)
            training_dl = DeviceDataLoader(training_dl, device)
            valid_dl = DeviceDataLoader(valid_dl, device)
            return training_dl, valid_dl, model
        except Exception as e:
            raise CustomException(e, sys)

    def train_model(self, model, train_dl, valid_dl):
        """
        Trains the model using a custom fit method.
        """
        try:
            logging.info("Starting training loop")
            fitted_model, result = my_fit_method(
                epochs=EPOCHS,
                lr=LEARNING_RATE,
                model=model,
                train_data_loader=train_dl,
                val_loader=valid_dl,
                opt_func=OPTIMIZER,
                grad_clip=GRAD_CLIP
            )
            logging.info("Training completed")
            return fitted_model, result
        except Exception as e:
            raise CustomException(e, sys)

    def initiate_model_trainer(self):
        """
        Entry point:
        - Creates transform
        - Loads spectrogram images
        - Trains model and saves artifacts
        """
        try:
            # Image transform: resize to fixed size and convert to tensor
            train_transform = tt.Compose([
                tt.Resize((201, 81)),  # match your spectrogram size
                tt.ToTensor()
            ])

            os.makedirs(self.model_trainer_config.model_trainer_artifact_dir, exist_ok=True)

            logging.info("Saving transform object for future inference")
            joblib.dump(train_transform, self.model_trainer_config.transformer_object_path)

            # Load images from transformation output
            image_root = self.data_transformation_artifact.images_folder_path
            logging.info(f"Loading training images from: {image_root}")
            train_data = ImageFolder(image_root, transform=train_transform)

            # Build loaders
            train_dl, valid_dl = self.get_data_loader(train_data)

            # Build model
            model = self.get_model(train_data)
            torch.cuda.empty_cache()

            # Move to device
            training_dl, valid_dl, model = self.load_to_gpu(train_dl, valid_dl, model)

            # Train
            fitted_model, result = self.train_model(model=model, train_dl=training_dl, valid_dl=valid_dl)

            # Save model weights
            logging.info(f"Saving model to: {self.model_trainer_config.model_path}")
            torch.save(fitted_model.state_dict(), self.model_trainer_config.model_path)

            # Return artifact
            model_trainer_artifact = ModelTrainerArtifacts(
                model_path=self.model_trainer_config.model_path,
                result=result,
                transformer_object_path=self.model_trainer_config.transformer_object_path
            )
            logging.info(f"Model trainer artifact: {model_trainer_artifact}")
            return model_trainer_artifact
        except Exception as e:
            raise CustomException(e, sys)
